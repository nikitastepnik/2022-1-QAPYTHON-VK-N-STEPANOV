{"name": "Проверка создания пользователя с middle-name", "status": "broken", "statusDetails": {"message": "sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\n(Background on this error at: https://sqlalche.me/e/14/e3q8)", "trace": "self = <pymysql.connections.Connection object at 0x7fa77a467fd0>, sock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG:\n                        print(\"connected using unix_socket\")\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs[\"source_address\"] = (self.bind_address, 0)\n                    while True:\n                        try:\n>                           sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout, **kwargs\n                            )\n\nexc        = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\nkwargs     = {}\nself       = <pymysql.connections.Connection object at 0x7fa77a467fd0>\nsock       = None\n\n/usr/local/lib/python3.8/site-packages/pymysql/connections.py:613: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('mysql', 3306), timeout = 10, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n            try:\n>               raise err\n\naddress    = ('mysql', 3306)\naf         = <AddressFamily.AF_INET: 2>\ncanonname  = ''\nerr        = None\nhost       = 'mysql'\nport       = 3306\nproto      = 6\nres        = (<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('172.24.0.4', 3306))\nsa         = ('172.24.0.4', 3306)\nsock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nsocktype   = <SocketKind.SOCK_STREAM: 1>\nsource_address = None\ntimeout    = 10\n\n/usr/local/lib/python3.8/socket.py:808: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('mysql', 3306), timeout = 10, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\naddress    = ('mysql', 3306)\naf         = <AddressFamily.AF_INET: 2>\ncanonname  = ''\nerr        = None\nhost       = 'mysql'\nport       = 3306\nproto      = 6\nres        = (<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_STREAM: 1>, 6, '', ('172.24.0.4', 3306))\nsa         = ('172.24.0.4', 3306)\nsock       = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nsocktype   = <SocketKind.SOCK_STREAM: 1>\nsource_address = None\ntimeout    = 10\n\n/usr/local/lib/python3.8/socket.py:796: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\nfn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>>\nconnection = None\n\n    def _wrap_pool_connect(self, fn, connection):\n        dialect = self.dialect\n        try:\n>           return fn()\n\nconnection = None\ndialect    = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\nfn         = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>>\nself       = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:3280: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n    def connect(self):\n        \"\"\"Return a DBAPI connection from the pool.\n    \n        The connection is instrumented such that when its\n        ``close()`` method is called, the connection will be returned to\n        the pool.\n    \n        \"\"\"\n>       return _ConnectionFairy._checkout(self)\n\nself       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:310: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'sqlalchemy.pool.base._ConnectionFairy'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nthreadconns = None, fairy = None\n\n    @classmethod\n    def _checkout(cls, pool, threadconns=None, fairy=None):\n        if not fairy:\n>           fairy = _ConnectionRecord.checkout(pool)\n\ncls        = <class 'sqlalchemy.pool.base._ConnectionFairy'>\nfairy      = None\npool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nthreadconns = None\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:868: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'sqlalchemy.pool.base._ConnectionRecord'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n    @classmethod\n    def checkout(cls, pool):\n>       rec = pool._do_get()\n\ncls        = <class 'sqlalchemy.pool.base._ConnectionRecord'>\npool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:476: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %0.2f\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n                return self._create_connection()\n            except:\n                with util.safe_reraise():\n>                   self._dec_overflow()\n\nself       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nuse_overflow = True\nwait       = False\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:146: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fa77a467340>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.raise_(\n                    exc_value,\n                    with_traceback=exc_tb,\n                )\n\nexc_tb     = <traceback object at 0x7fa77a558680>\nexc_type   = <class 'pymysql.err.OperationalError'>\nexc_value  = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\nself       = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fa77a467340>\ntraceback  = None\ntype_      = None\nvalue      = None\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def raise_(\n        exception, with_traceback=None, replace_context=None, from_=False\n    ):\n        r\"\"\"implement \"raise\" with cause support.\n    \n        :param exception: exception to raise\n        :param with_traceback: will call exception.with_traceback()\n        :param replace_context: an as-yet-unsupported feature.  This is\n         an exception object which we are \"replacing\", e.g., it's our\n         \"cause\" but we don't want it printed.    Basically just what\n         ``__suppress_context__`` does but we don't want to suppress\n         the enclosing context, if any.  So for now we make it the\n         cause.\n        :param from\\_: the cause.  this actually sets the cause and doesn't\n         hope to hide it someday.\n    \n        \"\"\"\n        if with_traceback is not None:\n            exception = exception.with_traceback(with_traceback)\n    \n        if from_ is not False:\n            exception.__cause__ = from_\n        elif replace_context is not None:\n            # no good solution here, we would like to have the exception\n            # have only the context of replace_context.__context__ so that the\n            # intermediary exception does not change, but we can't figure\n            # that out.\n            exception.__cause__ = replace_context\n    \n        try:\n>           raise exception\n\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/compat.py:207: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %0.2f\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n>               return self._create_connection()\n\nself       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nuse_overflow = True\nwait       = False\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:143: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n    def _create_connection(self):\n        \"\"\"Called by subclasses to create a new ConnectionRecord.\"\"\"\n    \n>       return _ConnectionRecord(self)\n\nself       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:256: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>, connect = True\n\n    def __init__(self, pool, connect=True):\n        self.__pool = pool\n        if connect:\n>           self.__connect()\n\nconnect    = True\npool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nself       = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:371: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n\n    def __connect(self):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.dbapi_connection = None\n        try:\n            self.starttime = time.time()\n            self.dbapi_connection = connection = pool._invoke_creator(self)\n            pool.logger.debug(\"Created new connection %r\", connection)\n            self.fresh = True\n        except Exception as e:\n            with util.safe_reraise():\n>               pool.logger.debug(\"Error on connect(): %s\", e)\n\npool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nself       = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:666: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fa77a467fa0>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.raise_(\n                    exc_value,\n                    with_traceback=exc_tb,\n                )\n\nexc_tb     = <traceback object at 0x7fa77a558400>\nexc_type   = <class 'pymysql.err.OperationalError'>\nexc_value  = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\nself       = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fa77a467fa0>\ntraceback  = None\ntype_      = None\nvalue      = None\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def raise_(\n        exception, with_traceback=None, replace_context=None, from_=False\n    ):\n        r\"\"\"implement \"raise\" with cause support.\n    \n        :param exception: exception to raise\n        :param with_traceback: will call exception.with_traceback()\n        :param replace_context: an as-yet-unsupported feature.  This is\n         an exception object which we are \"replacing\", e.g., it's our\n         \"cause\" but we don't want it printed.    Basically just what\n         ``__suppress_context__`` does but we don't want to suppress\n         the enclosing context, if any.  So for now we make it the\n         cause.\n        :param from\\_: the cause.  this actually sets the cause and doesn't\n         hope to hide it someday.\n    \n        \"\"\"\n        if with_traceback is not None:\n            exception = exception.with_traceback(with_traceback)\n    \n        if from_ is not False:\n            exception.__cause__ = from_\n        elif replace_context is not None:\n            # no good solution here, we would like to have the exception\n            # have only the context of replace_context.__context__ so that the\n            # intermediary exception does not change, but we can't figure\n            # that out.\n            exception.__cause__ = replace_context\n    \n        try:\n>           raise exception\n\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/compat.py:207: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n\n    def __connect(self):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.dbapi_connection = None\n        try:\n            self.starttime = time.time()\n>           self.dbapi_connection = connection = pool._invoke_creator(self)\n\npool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\nself       = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nconnection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n\n    def connect(connection_record=None):\n        if dialect._has_events:\n            for fn in dialect.dispatch.do_connect:\n                connection = fn(dialect, connection_record, cargs, cparams)\n                if connection is not None:\n                    return connection\n>       return dialect.connect(*cargs, **cparams)\n\ncargs      = []\nconnection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\ncparams    = {'client_flag': 2, 'database': 'vkeducation', 'host': 'mysql', 'password': 'qa_test', ...}\ndialect    = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/create.py:590: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\ncargs = ()\ncparams = {'client_flag': 2, 'database': 'vkeducation', 'host': 'mysql', 'password': 'qa_test', ...}\n\n    def connect(self, *cargs, **cparams):\n        # inherits the docstring from interfaces.Dialect.connect\n>       return self.dbapi.connect(*cargs, **cparams)\n\ncargs      = ()\ncparams    = {'client_flag': 2, 'database': 'vkeducation', 'host': 'mysql', 'password': 'qa_test', ...}\nself       = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/default.py:597: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x7fa77a467fd0>\n\n    def __init__(\n        self,\n        *,\n        user=None,  # The first four arguments is based on DB-API 2.0 recommendation.\n        password=\"\",\n        host=None,\n        database=None,\n        unix_socket=None,\n        port=0,\n        charset=\"\",\n        sql_mode=None,\n        read_default_file=None,\n        conv=None,\n        use_unicode=True,\n        client_flag=0,\n        cursorclass=Cursor,\n        init_command=None,\n        connect_timeout=10,\n        read_default_group=None,\n        autocommit=False,\n        local_infile=False,\n        max_allowed_packet=16 * 1024 * 1024,\n        defer_connect=False,\n        auth_plugin_map=None,\n        read_timeout=None,\n        write_timeout=None,\n        bind_address=None,\n        binary_prefix=False,\n        program_name=None,\n        server_public_key=None,\n        ssl=None,\n        ssl_ca=None,\n        ssl_cert=None,\n        ssl_disabled=None,\n        ssl_key=None,\n        ssl_verify_cert=None,\n        ssl_verify_identity=None,\n        compress=None,  # not supported\n        named_pipe=None,  # not supported\n        passwd=None,  # deprecated\n        db=None,  # deprecated\n    ):\n        if db is not None and database is None:\n            # We will raise warining in 2022 or later.\n            # See https://github.com/PyMySQL/PyMySQL/issues/939\n            # warnings.warn(\"'db' is deprecated, use 'database'\", DeprecationWarning, 3)\n            database = db\n        if passwd is not None and not password:\n            # We will raise warining in 2022 or later.\n            # See https://github.com/PyMySQL/PyMySQL/issues/939\n            # warnings.warn(\n            #    \"'passwd' is deprecated, use 'password'\", DeprecationWarning, 3\n            # )\n            password = passwd\n    \n        if compress or named_pipe:\n            raise NotImplementedError(\n                \"compress and named_pipe arguments are not supported\"\n            )\n    \n        self._local_infile = bool(local_infile)\n        if self._local_infile:\n            client_flag |= CLIENT.LOCAL_FILES\n    \n        if read_default_group and not read_default_file:\n            if sys.platform.startswith(\"win\"):\n                read_default_file = \"c:\\\\my.ini\"\n            else:\n                read_default_file = \"/etc/my.cnf\"\n    \n        if read_default_file:\n            if not read_default_group:\n                read_default_group = \"client\"\n    \n            cfg = Parser()\n            cfg.read(os.path.expanduser(read_default_file))\n    \n            def _config(key, arg):\n                if arg:\n                    return arg\n                try:\n                    return cfg.get(read_default_group, key)\n                except Exception:\n                    return arg\n    \n            user = _config(\"user\", user)\n            password = _config(\"password\", password)\n            host = _config(\"host\", host)\n            database = _config(\"database\", database)\n            unix_socket = _config(\"socket\", unix_socket)\n            port = int(_config(\"port\", port))\n            bind_address = _config(\"bind-address\", bind_address)\n            charset = _config(\"default-character-set\", charset)\n            if not ssl:\n                ssl = {}\n            if isinstance(ssl, dict):\n                for key in [\"ca\", \"capath\", \"cert\", \"key\", \"cipher\"]:\n                    value = _config(\"ssl-\" + key, ssl.get(key))\n                    if value:\n                        ssl[key] = value\n    \n        self.ssl = False\n        if not ssl_disabled:\n            if ssl_ca or ssl_cert or ssl_key or ssl_verify_cert or ssl_verify_identity:\n                ssl = {\n                    \"ca\": ssl_ca,\n                    \"check_hostname\": bool(ssl_verify_identity),\n                    \"verify_mode\": ssl_verify_cert\n                    if ssl_verify_cert is not None\n                    else False,\n                }\n                if ssl_cert is not None:\n                    ssl[\"cert\"] = ssl_cert\n                if ssl_key is not None:\n                    ssl[\"key\"] = ssl_key\n            if ssl:\n                if not SSL_ENABLED:\n                    raise NotImplementedError(\"ssl module not found\")\n                self.ssl = True\n                client_flag |= CLIENT.SSL\n                self.ctx = self._create_ssl_ctx(ssl)\n    \n        self.host = host or \"localhost\"\n        self.port = port or 3306\n        if type(self.port) is not int:\n            raise ValueError(\"port should be of type int\")\n        self.user = user or DEFAULT_USER\n        self.password = password or b\"\"\n        if isinstance(self.password, str):\n            self.password = self.password.encode(\"latin1\")\n        self.db = database\n        self.unix_socket = unix_socket\n        self.bind_address = bind_address\n        if not (0 < connect_timeout <= 31536000):\n            raise ValueError(\"connect_timeout should be >0 and <=31536000\")\n        self.connect_timeout = connect_timeout or None\n        if read_timeout is not None and read_timeout <= 0:\n            raise ValueError(\"read_timeout should be > 0\")\n        self._read_timeout = read_timeout\n        if write_timeout is not None and write_timeout <= 0:\n            raise ValueError(\"write_timeout should be > 0\")\n        self._write_timeout = write_timeout\n    \n        self.charset = charset or DEFAULT_CHARSET\n        self.use_unicode = use_unicode\n    \n        self.encoding = charset_by_name(self.charset).encoding\n    \n        client_flag |= CLIENT.CAPABILITIES\n        if self.db:\n            client_flag |= CLIENT.CONNECT_WITH_DB\n    \n        self.client_flag = client_flag\n    \n        self.cursorclass = cursorclass\n    \n        self._result = None\n        self._affected_rows = 0\n        self.host_info = \"Not connected\"\n    \n        # specified autocommit mode. None means use server default.\n        self.autocommit_mode = autocommit\n    \n        if conv is None:\n            conv = converters.conversions\n    \n        # Need for MySQLdb compatibility.\n        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}\n        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}\n        self.sql_mode = sql_mode\n        self.init_command = init_command\n        self.max_allowed_packet = max_allowed_packet\n        self._auth_plugin_map = auth_plugin_map or {}\n        self._binary_prefix = binary_prefix\n        self.server_public_key = server_public_key\n    \n        self._connect_attrs = {\n            \"_client_name\": \"pymysql\",\n            \"_pid\": str(os.getpid()),\n            \"_client_version\": VERSION_STRING,\n        }\n    \n        if program_name:\n            self._connect_attrs[\"program_name\"] = program_name\n    \n        if defer_connect:\n            self._sock = None\n        else:\n>           self.connect()\n\nauth_plugin_map = None\nautocommit = False\nbinary_prefix = False\nbind_address = None\ncharset    = ''\nclient_flag = 3842575\ncompress   = None\nconnect_timeout = 10\nconv       = {<class 'bool'>: <function escape_bool at 0x7fa77a9a60d0>, <class 'int'>: <function escape_int at 0x7fa77a9a6160>, <class 'float'>: <function escape_float at 0x7fa77a9a61f0>, <class 'str'>: <function escape_str at 0x7fa77a9a6430>, ...}\ncursorclass = <class 'pymysql.cursors.Cursor'>\ndatabase   = 'vkeducation'\ndb         = None\ndefer_connect = False\nhost       = 'mysql'\ninit_command = None\nlocal_infile = False\nmax_allowed_packet = 16777216\nnamed_pipe = None\npasswd     = None\npassword   = 'qa_test'\nport       = 3306\nprogram_name = None\nread_default_file = None\nread_default_group = None\nread_timeout = None\nself       = <pymysql.connections.Connection object at 0x7fa77a467fd0>\nserver_public_key = None\nsql_mode   = None\nssl        = None\nssl_ca     = None\nssl_cert   = None\nssl_disabled = None\nssl_key    = None\nssl_verify_cert = None\nssl_verify_identity = None\nunix_socket = None\nuse_unicode = True\nuser       = 'test_qa'\nwrite_timeout = None\n\n/usr/local/lib/python3.8/site-packages/pymysql/connections.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x7fa77a467fd0>, sock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG:\n                        print(\"connected using unix_socket\")\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs[\"source_address\"] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout, **kwargs\n                            )\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG:\n                        print(\"connected using socket\")\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = sock.makefile(\"rb\")\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n            self._request_authentication()\n    \n            if self.sql_mode is not None:\n                c = self.cursor()\n                c.execute(\"SET sql_mode=%s\", (self.sql_mode,))\n    \n            if self.init_command is not None:\n                c = self.cursor()\n                c.execute(self.init_command)\n                c.close()\n                self.commit()\n    \n            if self.autocommit_mode is not None:\n                self.autocommit(self.autocommit_mode)\n        except BaseException as e:\n            self._rfile = None\n            if sock is not None:\n                try:\n                    sock.close()\n                except:  # noqa\n                    pass\n    \n            if isinstance(e, (OSError, IOError, socket.error)):\n                exc = err.OperationalError(\n                    2003, \"Can't connect to MySQL server on %r (%s)\" % (self.host, e)\n                )\n                # Keep original exception and traceback to investigate error.\n                exc.original_exception = e\n                exc.traceback = traceback.format_exc()\n                if DEBUG:\n                    print(exc.traceback)\n>               raise exc\nE               pymysql.err.OperationalError: (2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\n\nexc        = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\nkwargs     = {}\nself       = <pymysql.connections.Connection object at 0x7fa77a467fd0>\nsock       = None\n\n/usr/local/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.fixture(scope='function')\n    def mysql_client_fixture():\n        with allure.step(\"Выполняем коннект к БД и возвращаем объект соединения\"):\n            mysql_client = MySqlClient()\n>           mysql_client.connect()\n\nmysql_client = <final_project.code.mysql.client.MySqlClient object at 0x7fa77a338cd0>\n\ncode/conftest.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ncode/mysql/client.py:26: in connect\n    self.connection = self.engine.connect()\n        self       = <final_project.code.mysql.client.MySqlClient object at 0x7fa77a338cd0>\n        url        = 'mysql+pymysql://test_qa:qa_test@mysql:3306/vkeducation'\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:3234: in connect\n    return self._connection_cls(self, close_with_result=close_with_result)\n        close_with_result = False\n        self       = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:96: in __init__\n    else engine.raw_connection()\n        _allow_revalidate = True\n        _branch_from = None\n        _dispatch  = None\n        _execution_options = None\n        _has_events = None\n        close_with_result = False\n        connection = None\n        engine     = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n        self       = <sqlalchemy.engine.base.Connection object at 0x7fa77a338d60>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:3313: in raw_connection\n    return self._wrap_pool_connect(self.pool.connect, _connection)\n        _connection = None\n        self       = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:3283: in _wrap_pool_connect\n    Connection._handle_dbapi_exception_noconnection(\n        connection = None\n        dialect    = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n        fn         = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>>\n        self       = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:2117: in _handle_dbapi_exception_noconnection\n    util.raise_(\n        cls        = <class 'sqlalchemy.engine.base.Connection'>\n        dialect    = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n        e          = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\n        engine     = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n        exc_info   = (<class 'pymysql.err.OperationalError'>, OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\"), <traceback object at 0x7fa77a558140>)\n        is_disconnect = False\n        newraise   = None\n        should_wrap = True\n        sqlalchemy_exception = OperationalError('(pymysql.err.OperationalError) (2003, \"Can\\'t connect to MySQL server on \\'mysql\\' ([Errno 111] Connection refused)\")')\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/compat.py:207: in raise_\n    raise exception\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py:3280: in _wrap_pool_connect\n    return fn()\n        connection = None\n        dialect    = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n        fn         = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>>\n        self       = Engine(mysql+pymysql://test_qa:***@mysql:3306/vkeducation)\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:310: in connect\n    return _ConnectionFairy._checkout(self)\n        self       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:868: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n        cls        = <class 'sqlalchemy.pool.base._ConnectionFairy'>\n        fairy      = None\n        pool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n        threadconns = None\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:476: in checkout\n    rec = pool._do_get()\n        cls        = <class 'sqlalchemy.pool.base._ConnectionRecord'>\n        pool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:146: in _do_get\n    self._dec_overflow()\n        self       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n        use_overflow = True\n        wait       = False\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:70: in __exit__\n    compat.raise_(\n        exc_tb     = <traceback object at 0x7fa77a558680>\n        exc_type   = <class 'pymysql.err.OperationalError'>\n        exc_value  = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\n        self       = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fa77a467340>\n        traceback  = None\n        type_      = None\n        value      = None\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/compat.py:207: in raise_\n    raise exception\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/impl.py:143: in _do_get\n    return self._create_connection()\n        self       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n        use_overflow = True\n        wait       = False\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:256: in _create_connection\n    return _ConnectionRecord(self)\n        self       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:371: in __init__\n    self.__connect()\n        connect    = True\n        pool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n        self       = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:666: in __connect\n    pool.logger.debug(\"Error on connect(): %s\", e)\n        pool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n        self       = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/langhelpers.py:70: in __exit__\n    compat.raise_(\n        exc_tb     = <traceback object at 0x7fa77a558400>\n        exc_type   = <class 'pymysql.err.OperationalError'>\n        exc_value  = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\n        self       = <sqlalchemy.util.langhelpers.safe_reraise object at 0x7fa77a467fa0>\n        traceback  = None\n        type_      = None\n        value      = None\n/usr/local/lib/python3.8/site-packages/sqlalchemy/util/compat.py:207: in raise_\n    raise exception\n/usr/local/lib/python3.8/site-packages/sqlalchemy/pool/base.py:661: in __connect\n    self.dbapi_connection = connection = pool._invoke_creator(self)\n        pool       = <sqlalchemy.pool.impl.QueuePool object at 0x7fa77a467cd0>\n        self       = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/create.py:590: in connect\n    return dialect.connect(*cargs, **cparams)\n        cargs      = []\n        connection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x7fa77a467f10>\n        cparams    = {'client_flag': 2, 'database': 'vkeducation', 'host': 'mysql', 'password': 'qa_test', ...}\n        dialect    = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/default.py:597: in connect\n    return self.dbapi.connect(*cargs, **cparams)\n        cargs      = ()\n        cparams    = {'client_flag': 2, 'database': 'vkeducation', 'host': 'mysql', 'password': 'qa_test', ...}\n        self       = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x7fa77a467ac0>\n/usr/local/lib/python3.8/site-packages/pymysql/connections.py:353: in __init__\n    self.connect()\n        auth_plugin_map = None\n        autocommit = False\n        binary_prefix = False\n        bind_address = None\n        charset    = ''\n        client_flag = 3842575\n        compress   = None\n        connect_timeout = 10\n        conv       = {<class 'bool'>: <function escape_bool at 0x7fa77a9a60d0>, <class 'int'>: <function escape_int at 0x7fa77a9a6160>, <class 'float'>: <function escape_float at 0x7fa77a9a61f0>, <class 'str'>: <function escape_str at 0x7fa77a9a6430>, ...}\n        cursorclass = <class 'pymysql.cursors.Cursor'>\n        database   = 'vkeducation'\n        db         = None\n        defer_connect = False\n        host       = 'mysql'\n        init_command = None\n        local_infile = False\n        max_allowed_packet = 16777216\n        named_pipe = None\n        passwd     = None\n        password   = 'qa_test'\n        port       = 3306\n        program_name = None\n        read_default_file = None\n        read_default_group = None\n        read_timeout = None\n        self       = <pymysql.connections.Connection object at 0x7fa77a467fd0>\n        server_public_key = None\n        sql_mode   = None\n        ssl        = None\n        ssl_ca     = None\n        ssl_cert   = None\n        ssl_disabled = None\n        ssl_key    = None\n        ssl_verify_cert = None\n        ssl_verify_identity = None\n        unix_socket = None\n        use_unicode = True\n        user       = 'test_qa'\n        write_timeout = None\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x7fa77a467fd0>, sock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG:\n                        print(\"connected using unix_socket\")\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs[\"source_address\"] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout, **kwargs\n                            )\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG:\n                        print(\"connected using socket\")\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = sock.makefile(\"rb\")\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n            self._request_authentication()\n    \n            if self.sql_mode is not None:\n                c = self.cursor()\n                c.execute(\"SET sql_mode=%s\", (self.sql_mode,))\n    \n            if self.init_command is not None:\n                c = self.cursor()\n                c.execute(self.init_command)\n                c.close()\n                self.commit()\n    \n            if self.autocommit_mode is not None:\n                self.autocommit(self.autocommit_mode)\n        except BaseException as e:\n            self._rfile = None\n            if sock is not None:\n                try:\n                    sock.close()\n                except:  # noqa\n                    pass\n    \n            if isinstance(e, (OSError, IOError, socket.error)):\n                exc = err.OperationalError(\n                    2003, \"Can't connect to MySQL server on %r (%s)\" % (self.host, e)\n                )\n                # Keep original exception and traceback to investigate error.\n                exc.original_exception = e\n                exc.traceback = traceback.format_exc()\n                if DEBUG:\n                    print(exc.traceback)\n>               raise exc\nE               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\nE               (Background on this error at: https://sqlalche.me/e/14/e3q8)\n\nexc        = OperationalError(2003, \"Can't connect to MySQL server on 'mysql' ([Errno 111] Connection refused)\")\nkwargs     = {}\nself       = <pymysql.connections.Connection object at 0x7fa77a467fd0>\nsock       = None\n\n/usr/local/lib/python3.8/site-packages/pymysql/connections.py:664: OperationalError"}, "description": "\n         Тестирование: Добавление пользователя (c middle-name)\n         Эндпоинт: POST http://127.0.0.1:8086/api/user\n         Предусловия: Авторизация, создание пользовательских данных\n         Шаги:\n         1. Отправка запроса по API\n         2. Найти пользователя по email в БД\n         3. Удалить из БД ранее созданного пользователя\n         Ожидаемый результат:\n         Пользователь добавляется в БД с корректными данными (+)\n         Код ответа - 201 (\"Created\") (-)\n         Фактический результат:\n         Пользователь добавляется в БД с корректными данными\n         Код ответа - 210\n         ", "start": 1653175437807, "stop": 1653175437807, "uuid": "79f398a3-07ac-46b7-9baf-feba08218ec4", "historyId": "9cf23cc3cba1c157d4f200762bb9460c", "testCaseId": "cc002384ad2ac99c1d99c86c21c5d7c3", "fullName": "code.api_myapp.test.test_api.TestApiAuthorizedUser#test_post_create_user_with_middle_name_bug", "labels": [{"name": "tag", "value": "API"}, {"name": "parentSuite", "value": "code.api_myapp.test"}, {"name": "suite", "value": "test_api"}, {"name": "subSuite", "value": "TestApiAuthorizedUser"}, {"name": "host", "value": "ebf8aaa79544"}, {"name": "thread", "value": "1-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "code.api_myapp.test.test_api"}]}